% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/dsmartr_collate.R
\name{collate}
\alias{collate}
\title{Collate dsmartr iterations}
\usage{
collate(iteration_stack = NULL, lookup = NULL, cpus = 1)
}
\arguments{
\item{iteration_stack}{RasterStack or Brick; output \code{iteration_maps}
from \code{\link{iterate}}.}

\item{lookup}{Data Frame; contains raster values and corresponding soil class
labels. Example:
\preformatted{'data.frame':    38 obs. of  2 variables:
$ VALUE: int  1 2 3 4 5 6 7 8 9 10 ...
$ CLASS: chr  "Ad" "An" "Bb" "Bh" ...}}

\item{cpus}{Integer; number of processors to use in parallel.}
}
\value{
A list of four RasterStacks:
\itemize{
  \item{\code{dsmartr_predictions}: RasterStack, soil class prediction maps
  in order of most to least-probable}
  \item{\code{dsmartr_probabilties}: RasterStack, a probability surface for
  each layer of \code{dsmartr_predictions}.}
  \item{\code{tallied_predictions}: RasterStack containing per-pixel tallies
  of soil class occurrence.}
  \item{\code{tallied_probabilities}: RasterStack containing per-pixel
  probabilities of soil class occurrence}.}

All outputs are written to disk as multiband GeoTIFFs before being assigned
to the global environment.
}
\description{
Processes the outputs of \code{\link[dsmartr:iterate]{iterate}}
}
\note{
This function can generate very large R temporary files. A rough
  minimum disk space requirement is \code{n} iterations * \code{n} covariate
  cells * 8 bytes * 2.
}
\examples{
\dontrun{
# run iterate() with the example data, then:
LUT <- levels(iteration_maps[[1]])[[1]]
collated <- collate(iteration_stack = iteration_maps, lookup = LUT,
 cpus = max(1, (parallel::detectCores() - 1)))
 }
}
